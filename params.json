{"name":"Pyblish", "tagline":"Plug-in driven quality assurance framework for content","body":"Pyblish is a feature film-strength quality assurance framework for content.\r\n\r\n# Overview\r\n\r\nSome of the immediate benefits of using Pyblish are\r\n\r\n- [Higher quality content](#higher-quality-content)\r\n- [Greater content reuse](#greater-reuse-of-content)\r\n- [Lower iteration times](#lower-iteration-time)\r\n- [Shortened learning curve](#shortened-learning-curve)\r\n\r\n##### Higher quality content\r\n\r\nWhen looking out over your content, it can be difficult to know what quality standards it all falls under. Some files may have been perfected while others may be haphazardly put together by an intern. Passing data through validations is one way of reducing the range of quality differences throughout your library of content.\r\n\r\n##### Greater reuse of content\r\n\r\nTraditionally, as projects come and go, you tend to end up with a rather large library of assets. Unfortunately, most of these assets are often tightly tailored to their parent project and rarely usable once complete. But when content from Project A looks and works similar to Project B, it isn't too far of a stretch to imagine it fitting in with Project C, D and E as well.\r\n\r\n##### Lowered iteration time\r\n\r\nSending content back to the artist responsible for creating it is a major time sink. Due to data being validated prior to being passed on using Pyblish, this can be reduced drastically and artists can share content effortlessly and with confident that it will work.\r\n\r\n##### Shortened learning curve\r\n\r\nWhen validating data, the state of each file may come as less of a surprise to the artist making use of it. Traditionally, handing data from one artist to another typically involves an ad-hoc process of one explaining his methods and conventions to the other so that the content can be continued upon. With Pyblish, an organisation can pre-define conventions upon each category of content so as to minimise the amount of new information present within each file.\r\n\r\nThis works both ways, a new artists sharing his work with others must first become comfortable with the conventions already in place. Traditionally, this is a process of trail and error where an artist must study the implicit conventions of others and continually make improvements upon his work until it conforms to the overall quality produced by his peers. This comes at a cost not only to himself, but to others who discover the flaws and send it back. A process known as \"passing shit downstream\". With Pyblish, this can be drastically reduced and artist, both veteran or novice, can confidently provide others with content living up to par with the organisation.\r\n\r\n# Installation\r\n\r\nThe best way to learn anything is to try things out. So let's get Pyblish installed!\r\n\r\n```bash\r\n# Pyblish is a regular Python package, available on PyPI\r\n$ pip install pyblish\r\n```\r\n\r\nTo test things out, let's try and import our newly installed package.\r\n\r\n```python\r\nPython 2.7.7 (default, Jun  1 2014, 14:21:57)\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import pyblish\r\n>>> pyblish.version\r\n'0.1.16'\r\n```\r\n\r\n> If this isn't the results you've got, head on over to [[Troubleshooting|end-user-troubleshooting]] and we'll try and get things sorted.\r\n\r\nFor a gold star, run the included test-suite.\r\n\r\n```cmd\r\n$ cd c:\\Python27\\Lib\\site-packages\\pyblish\r\n$ python -m pyblish.vendor.nose --verbose --exclude=vendor --with-doctest\r\nThe data() interface works ... ok\r\nConfig works as expected ... ok\r\nMain interface works ... ok\r\n...\r\n\r\n----------------------------------------------------------------------\r\nRan 25 tests in 0.071s\r\n```\r\n\r\nUnless it said anything except how many tests it ran, you're good to go!\r\n\r\n# Integrations\r\n\r\nYou've just installed Pyblish, but Pyblish isn't much without any of its integrations. Let's have a look at the Maya integration.\r\n\r\n[![](https://github.com/abstractfactory/pyblish/wiki/images/maya-pyblish.png)][maya]\r\n\r\n[maya]: https://github.com/abstractfactory/pyblish-maya/wiki\r\n\r\n# Installing the Maya integration\r\n\r\nIf you haven't already installed Pyblish, head on over the the [Pyblish installation guide][Pyblish] to get started. Once ready, run this.\r\n\r\n```bash\r\n# Pyblish for Maya is a regular Python package on PyPI\r\n$ pip install pyblish-maya\r\n```\r\n\r\n> Currently, Pyblish only works with Maya 2014 and upwards.\r\n\r\n[Pyblish]: https://github.com/abstractfactory/pyblish/wiki/Installing\r\n\r\n### Installing the integration into Maya\r\n\r\nThe next step is to expose the integration to Maya. For this, you've got two options.\r\n\r\n1. Append a `userSetup.py` to your PYTHONPATH\r\n\r\n ```bash\r\n# Typically, the integration is located here\r\nc:\\Python27\\Lib\\site-packages\\pyblish_maya\\pythonpath\r\n```\r\n\r\n Append this path to your `PYTHONPATH`. See here for [help with modifying your environment][var]\r\n\r\n2. Append to your own `userSetup.py`\r\n\r\n ```bash\r\n# Typically located here:\r\nC:\\Users\\marcus\\Documents\\maya\\scripts\r\n```\r\n\r\n Append the following\r\n\r\n ```python\r\nimport pyblish_maya.lib\r\npyblish_maya.lib.register_plugins()\r\npyblish_maya.lib.add_to_filemenu()\r\n```\r\n\r\n[var]: https://github.com/abstractfactory/pyblish/wiki/Adding-an-environment-variable\r\n\r\n### Testing things out\r\n\r\nThe next time you open up Maya, look for an item in your `File` menu that reads \"Publish\". If you haven't got it, head over to the [[Troubleshooting|troubleshooting]] section and we'll get you sorted out.\r\n\r\n# Making your first Publish\r\n\r\n> This guide assumes you've got a freshly installed version of Maya and that you haven't changed it's project directory.\r\n\r\nBy the end of this page, sir, *you* will have made your first publish. Just follow these steps one by one and we'll take you through how to make it happen.\r\n\r\n**Table of contents**\r\n\r\n- [Create something](#create-something)\r\n- [Publish - 1st attempt](#publish-1st-attempt)\r\n- [Select it](#select-it)\r\n- [Publish - 2nd attempt](#publish-2nd-attempt)\r\n- [Make it publishable](#make-it-publishable)\r\n- [Publish - 3rd attempt](#publish-3rd-attempt)\r\n- [Dissection](#dissection)\r\n - [Where did the publish go?](#where-did-the-publish-go)\r\n - [How it works](#how-it-works)\r\n - [5 minutes later](#5-minutes-later)\r\n - [Why did it go there?](#why-did-the-publish-go-there)\r\n - [Where did the naming convention come from?](#where-did-the-naming-convention-come-from)\r\n- [Conclusion](#conclusion)\r\n\r\n### Create something\r\n\r\nHow about a cube.\r\n\r\n1. In your `Create` menu\r\n2. Click `Polygon Primitives`\r\n3. Click `Cube`\r\n4. Rename your cube to \"myCube\"\r\n\r\nOr type the following in your script editor.\r\n\r\n```python\r\nfrom maya import cmds\r\ncmds.polyCube(name='myCube')\r\n```\r\n\r\n### Publish - 1st attempt\r\n\r\nAllright, let's try publishing.\r\n\r\n1. In your `File` menu\r\n2. Click `Publish`\r\n\r\nOr type the following:\r\n\r\n```python\r\nimport pyblish.main\r\npyblish.main.publish_all()\r\n```\r\n\r\nHmm. You're cube should have been published by now, but instead you've got a message saying:\r\n\r\n```python\r\n# No instances found. # \r\n```\r\n\r\nWhat is that all about? As it turns out, there are just a few more steps we'll need to take before the button will know of exactly what and how you would like to perform your publish.\r\n\r\n### Select it\r\n\r\n*Select* is an important keyword in Pyblish. To *Select*, in Pyblish, means to specify what you would like to have published.\r\n\r\nTo select your cube, add it to a selection set.\r\n\r\n1. In your `Create` menu\r\n2. Click `Sets`\r\n3. Followed by `Set`\r\n4. Rename your set to \"MyCube\"\r\n\r\nOr, type the following:\r\n\r\n```python\r\ncmds.sets(name='MyCube')\r\n```\r\n\r\nIf you didn't have `myCube` selected when you created the set, make sure to add it to the set, either by dragging-and-dropping or by typing:\r\n\r\n```python\r\ncmds.sets('myCube', addElement='MyCube')\r\n```\r\n\r\n### Publish - 2nd attempt\r\n\r\nAllright, let's try that again.\r\n\r\n1. In your `File` menu\r\n2. Click `Publish`\r\n\r\nOr type the following:\r\n\r\n```python\r\nimport pyblish.main\r\npyblish.main.publish_all()\r\n```\r\n\r\nHmm, we're still missing something.\r\n\r\n```python\r\n# No instances found. # \r\n```\r\n\r\n### Make it publishable\r\n\r\nFor Pyblish to know that *this* is what you would like to Publish, and nothing else, we need to tag the selection set. To tag it, add the following attributes and values.\r\n\r\n```yaml\r\npublishable (bool): True\r\nfamily (string): \"demo.model\"\r\n```\r\n\r\nYou can add it by going to your [Channel Box][chan].\r\n\r\n1. In your `Edit` menu\r\n2. Click `Add Attribute`\r\n3. Type `publishable` as `Long name`\r\n4. Click `Boolean` as `Data Type`\r\n5. Hit `Add`\r\n6. Type `family` as `Long name`\r\n7. Click `String` as `Data Type`\r\n8. Hit `OK`\r\n\r\nOr type the following:\r\n\r\n```python\r\ncmds.addAttr('MyCube', at='bool', longName='publishable')\r\ncmds.addAttr('MyCube', dt='string', longName='family')\r\n```\r\n\r\nNext, fill in the values.\r\n\r\n1. In your [Attribute Editor][attributeeditor]\r\n2. Under `Extra Attributes`\r\n3. Toggle `publishable` to True\r\n4. Type `demo.model` in the `family` text box\r\n\r\nOr type the following:\r\n\r\n```python\r\ncmds.setAttr('MyCube.publishable', True)\r\ncmds.setAttr('MyCube.family', 'demo.model', type='string')\r\n```\r\n\r\nNow Pyblish will be able to distinguish between this set and any other set you might have.\r\n\r\n### Publish - 3rd attempt\r\n\r\nThird time's the charm, right?\r\n\r\n1. In your `File` menu\r\n2. Click `Publish`\r\n\r\nOr type the following:\r\n\r\n```python\r\nimport pyblish.main\r\npyblish.main.publish_all()\r\n```\r\n\r\n**Error!**\r\n\r\n```python\r\n# Error:\r\n# ValueError: The following nodes were misnamed\r\n# \tmyCube\r\n```\r\n\r\nUh-oh. Looks like we've got a new error this time. By the looks of it, our Cube wasn't named according to the naming conventions. Let's try and remedy this. Currently, the naming convention is for everything you publish to always have a three-letter extension.\r\n\r\n1. Rename `myCube` to `myCube_GEO`\r\n2. Re-run the publish\r\n\r\nYou should now see this message in your script editor.\r\n\r\n```bash\r\n# Finished successfully #\r\n```\r\n\r\n[chan]: http://download.autodesk.com/global/docs/maya2014/en_us/files/GUID-424694BA-019A-4D05-86EF-F9CD0A69D92C.htm\r\n[attributeeditor]: http://download.autodesk.com/global/docs/maya2014/en_us/files/GUID-67A58D31-4722-4769-B3E6-1A35B5B53BED.htm\r\n\r\n# Dissection\r\n\r\nOk, let's back up a second and reflect on what happened. There are a couple of questions left unanswered from running your first publish above.\r\n\r\n1. Where did the publish go?\r\n1. Why did it go there?\r\n1. Where did the naming convention come from?\r\n1. Why did we have to add the two attributes, `publishable` and `family`?\r\n1. Why did we have to put `myCube` into a selection set?\r\n\r\nFrom the top:\r\n\r\n1. To your workspace.\r\n1. Because the plugin `extract_as_ma` put it there.\r\n1. From the plugin `validate_naming_convention`.\r\n1. Because the plugin `select_object_set` was looking for it.\r\n1. Because the plugin `select_object_set` was looking for this too.\r\n\r\nToo direct? Yes, let's have a closer look at how all of this fits together.\r\n\r\n### Where did the publish go?\r\n\r\n> To your workspace.\r\n\r\nIf you look within your project directory, you'll notice that you've now got a new folder called `published`.\r\n\r\n```\r\nC:\\Users\\marcus\\Documents\\maya\\projects\\default\\published\r\n```\r\n\r\nThis is where Pyblish chose to store `MyCube` when you hit the Publish button. But how did it know to do that? And why did it put it in a subdirectory that looks like the current date and time, followed by a few other directories?\r\n\r\n- [ ] [[/images/octicon-file-directory.png]] published\r\n - [ ] [[/images/octicon-file-directory.png]] 20140907-174550\r\n   - [ ] [[/images/octicon-file-directory.png]] demo.model\r\n     - [ ] [[/images/octicon-file-directory.png]] MyCube\r\n\r\nAnd how did it know to produce 4 files? Why not 5, or 3? \r\n\r\n- [ ] [[/images/octicon-file-directory.png]] MyCube\r\n - [ ] [[/images/octicon-file.png]] MyCube.ma\r\n - [ ] [[/images/octicon-file.png]] MyCube.mb\r\n - [ ] [[/images/octicon-file.png]] MyCube.obj\r\n - [ ] [[/images/octicon-file.png]] MyCube.mtl\r\n\r\nWell, the answer lies in the plugins.\r\n\r\n#### How it works\r\n\r\nIf you haven't already done so, now would be an excellent time to read [How It Works][works]. It'll provide you with an overview of how Pyblish processes your publishes. Once you're ready, come back here and we'll continue.\r\n\r\n- [How It Works][works]\r\n\r\n[works]: https://github.com/abstractfactory/pyblish/wiki/End-User-How-it-works\r\n\r\n### 5 minutes later\r\n\r\n> Ok, so a selection plugin *selects* the cube?\r\n\r\nYes. It knows to do this because of how it is implemented.\r\n\r\nIt looks for nodes of type `objectSet` in your scene; specifically, nodes with the two attributes we added - `publishable` and `family`.\r\n\r\nIf you were to remove any of these two, the selector would go blind.\r\n\r\n> Can I add anything to the `objectSet`?\r\n\r\nYes you can! That is the whole idea - you add what you intend on sharing with others. This way, you can separate the part of your scene that is sharable from the part that is not.\r\n\r\n> What about the two attributes. What are they?\r\n\r\nThat's a good question. The `publishable` is merely an attribute to help the selector distinguish the nodes you are interested in publishing from those you are not. It's a way for the node to say \"Me! Me! Me!\" when you've got three identical nodes in your scene.\r\n\r\nRemember when Neo took the red pill and they were able to locate him amongst a field of pods identical to his own?\r\n\r\n`family` is where things start getting interesting. The family is a critical element of Pyblish. It's a way of saying \"*this* instance belongs to *this* group of plugins\". If you look at the selection set in your scene from your Attribute Editor, under \"Extra Attributes\", you'll see that the family attribute has the value \"demo.model\".\r\n\r\n```python\r\nprint cmds.getAttr('MyCube.family')\r\n```\r\n\r\n> \"demo.model\"?\r\n\r\nYes, this is a way for the instance to say \"I'd like all plugins compatible with `demo.model` to process me\". Each plugin is associated with at least one (1) family. In effect, the instance is processed by a number of plugins compatible with this family.\r\n\r\n```python\r\n# A plugin may support multiple families, but\r\n# an instance may only support one.\r\n _______________        _______________\r\n|               |      |               |\r\n| Instance      |      | Plugin        |\r\n|               |      |               |\r\n|    demo.model o----->o demo.model    |\r\n|               |      o demo.anim     |\r\n|               |      o demo.rig      |\r\n|_______________|      |_______________|\r\n```\r\n\r\n> I'm confused..\r\n\r\nDon't worry, this will make more sense once we get a little bit further in learning about Pyblish. All you need to remember from this is that each plugin carries a list of supported families and that all instances carries exactly one (1) family that may or may not match any of the available plugins.\r\n\r\n### Why did the publish go there?\r\n\r\n> Because the plugin `extract_as_ma` put it there.\r\n\r\nWell, if you remember from the [**How It Works**][works], once selection and validation was complete, extraction took over. One of the extractors - specifically, one called `extract_as_ma` - is responsible for putting the files where they ended up.\r\n\r\nRemember, the primary responsibility of an extractor is *getting data out of an application*. It doesn't have much concern for exactly where the data ends up, as that is not within its responsibilities. Instead, this responsibility is delegated to conformers.\r\n\r\n> Why couldn't the extractor just put the files where I want them right away?\r\n\r\nThey most certainly could, this is merely a guideline. The separation is made due to cases where you have one or more things happening to content once it exits an application.\r\n\r\n1. Data is moved to one location\r\n1. Data is archived in another location\r\n1. The event is logger with a task tracking solution\r\n\r\nFor example, ask yourself these questions.\r\n\r\n- What about when the network is down and it can't move the files to where they belong? \r\n- What about when the internet is down and the event can't be logged?\r\n- Should this stop the application from exporting the data?\r\n\r\nThese are concerns well suited for conformers.\r\n\r\n### Where did the naming convention come from?\r\n\r\n> From the plugin `validate_naming_convention`.\r\n\r\nBy now, you can probably answer the remaining questions yourself. But there is one important aspect I'd like to point out regarding the naming convention plugin.\r\n\r\nThe reason this naming convention was applied to \"myCube_GEO\" was because we specified that this cube was of family \"demo.model\".\r\n\r\nWe associated this family with our cube and in effect said \"associate this particular naming convention to this cube\".\r\n\r\n# Conclusion\r\n\r\nOk, time for a breather. \r\n\r\nWe've covered a lot of ground here but if there is one thing I'd like you to take with you it is that the manner in which we just published your first instance is fully dictated by the plugins currently exposed to Pyblish by the time you initiate your publish and that these plugins are just demos.\r\n\r\nPyblish is a \"eat your own dog-food\" library in that anything it does it does in the same manner you would do it if you were the one implementing the behaviour. We think this is important and it keeps us honest and our implementations open for learning and modification.\r\n\r\nYou're probably very excited about writing your own plugins by now, so let's do that! If you've saved your work (you'll need it next), head on the the next tutorial by clicking the link below.\r\n\r\n### [[Creating your first plugin >>|Creating-Your-First-Plugin]]\r\n[process]: https://github.com/abstractfactory/pyblish/wiki/End-User-Pyblish-Process","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}